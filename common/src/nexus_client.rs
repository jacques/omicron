/*!
 * Interface for making API requests to the Oxide control plane at large
 * from within the control plane
 *
 * This should be replaced with a client generated from the OpenAPI spec
 * generated by the server.
 */

use crate::api::external::Error;
use crate::api::internal::nexus::DatasetPostRequest;
use crate::api::internal::nexus::DatasetPostResponse;
use crate::api::internal::nexus::DiskRuntimeState;
use crate::api::internal::nexus::InstanceRuntimeState;
use crate::api::internal::nexus::SledAgentStartupInfo;
use crate::api::internal::nexus::ZpoolPostRequest;
use crate::api::internal::nexus::ZpoolPostResponse;
use crate::http_client::HttpClient;
use http::Method;
use hyper::Body;
use slog::Logger;
use std::net::SocketAddr;
use uuid::Uuid;

/** Client for a nexus instance */
pub struct Client {
    /** underlying HTTP client */
    client: HttpClient,
}

impl Client {
    /**
     * Create a new nexus client to make requests to the Nexus instance at
     * `server_addr`.
     */
    pub fn new(server_addr: SocketAddr, log: Logger) -> Client {
        Client { client: HttpClient::new("nexus", server_addr, log) }
    }

    /**
     * Publish information about a sled agent's startup.
     */
    pub async fn notify_sled_agent_online(
        &self,
        id: Uuid,
        info: SledAgentStartupInfo,
    ) -> Result<(), Error> {
        let path = format!("/sled_agents/{}", id);
        let body = Body::from(serde_json::to_string(&info).unwrap());
        self.client.request(Method::POST, path.as_str(), body).await.map(|_| ())
    }

    /// Publish information about a zpool.
    pub async fn zpool_post(
        &self,
        zpool_id: Uuid,
        sled_id: Uuid,
        info: ZpoolPostRequest,
    ) -> Result<ZpoolPostResponse, Error> {
        let path = format!("/sled_agents/{}/zpools/{}", sled_id, zpool_id);
        let body = Body::from(serde_json::to_string(&info).unwrap());
        let mut response =
            self.client.request(Method::POST, path.as_str(), body).await?;
        assert!(response.status().is_success());
        let value = self
            .client
            .read_json::<ZpoolPostResponse>(
                &self.client.error_message_base(&Method::PUT, path.as_str()),
                &mut response,
            )
            .await?;
        Ok(value)
    }

    /// Publish information about a dataset.
    pub async fn dataset_post(
        &self,
        dataset_id: Uuid,
        zpool_id: Uuid,
        info: DatasetPostRequest,
    ) -> Result<DatasetPostResponse, Error> {
        let path = format!("/zpools/{}/dataset/{}", zpool_id, dataset_id);
        let body = Body::from(serde_json::to_string(&info).unwrap());
        let mut response =
            self.client.request(Method::POST, path.as_str(), body).await?;
        assert!(response.status().is_success());
        let value = self
            .client
            .read_json::<DatasetPostResponse>(
                &self.client.error_message_base(&Method::PUT, path.as_str()),
                &mut response,
            )
            .await?;
        Ok(value)
    }

    /**
     * Publish an updated runtime state for an Instance.
     */
    pub async fn notify_instance_updated(
        &self,
        id: &Uuid,
        new_runtime_state: &InstanceRuntimeState,
    ) -> Result<(), Error> {
        let path = format!("/instances/{}", id);
        let body =
            Body::from(serde_json::to_string(new_runtime_state).unwrap());
        self.client.request(Method::PUT, path.as_str(), body).await.map(|_| ())
    }

    /**
     * Publish an updated runtime state for a Disk.
     */
    pub async fn notify_disk_updated(
        &self,
        id: &Uuid,
        new_state: &DiskRuntimeState,
    ) -> Result<(), Error> {
        let path = format!("/disks/{}", id);
        let body = Body::from(serde_json::to_string(new_state).unwrap());
        self.client.request(Method::PUT, path.as_str(), body).await.map(|_| ())
    }
}
