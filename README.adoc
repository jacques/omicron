:showtitle:
:toc: left
:icons: font

= Oxide API Prototype

This repo houses a prototype for the Oxide Rack API.  See:

* https://4.rfd.oxide.computer[RFD 4 User Facing API Design]
* https://10.rfd.oxide.computer[RFD 10 API Prototype and Simulated
  Implementation]
* https://48.rfd.oxide.computer[RFD 48 Control Plane Architecture]

== Status

The code here is still rough, but the following are implemented:

* actual API: basic CRUD support for projects and instances
* Dropshot: a general-purpose crate for building an HTTP API server, including
  basic routing with path parameters; strong types for request and response
  bodies; basic query parameter support; ergonomic error handling; OpenAPI
  support; and request ids
* basic server infrastructure: configuration, logging
* test coverage for most of the above

See <<_todo>> for more info.

== Build and run

The server requires a configuration file to run.  You can use
`examples/config.toml` to start with.  Build and run the server:

[source,text]
----
$ cargo run -- examples/config.toml
...
listening: http://127.0.0.1:12220
----

Use `curl` to hit the server:

[source,text]
----
$ curl -i http://localhost:12220/projects
HTTP/1.1 200 OK
content-type: application/x-ndjson
x-request-id: 980984b3-60b8-4319-ae5a-a06f79529ee0
content-length: 489
date: Wed, 01 Apr 2020 23:02:22 GMT

{"name":"simproject1","description":"<auto-generated at server startup>","timeCreated":"2020-04-01T23:02:19.115004Z","timeModified":"2020-04-01T23:02:19.115004Z"}
{"name":"simproject2","description":"<auto-generated at server startup>","timeCreated":"2020-04-01T23:02:19.115004Z","timeModified":"2020-04-01T23:02:19.115004Z"}
{"name":"simproject3","description":"<auto-generated at server startup>","timeCreated":"2020-04-01T23:02:19.115004Z","timeModified":"2020-04-01T23:02:19.115004Z"}
----

You can run the tests with `cargo test`.  The test suite runs cleanly and should
remain clean.

== Configuration

The server requires a TOML configuration file.  There's an example in
`examples/config.toml`:

[source,toml]
----
include::examples/config.toml[]
----

Supported config properties include:

[cols="4",options="header"]
|===
|Name
|Example
|Required?
|Description

|`dropshot.bind_address`
|`"127.0.0.1:12220"`
|Yes
|Specifies that the server should bind to the given IP address and TCP port.  In
general, servers can bind to more than one IP address and port, but this is not
(yet?) supported.

|`log.mode`
|`"file"`
|Yes
|Controls where server logging will go.  Valid modes are `"stderr-terminal"` and
`"file".  If the mode is `"stderr-terminal"`, human-readable output, with colors
and other terminal formatting if possible, will be sent to stderr.  If the mode
is `"file"`, Bunyan-format output will be sent to the filesystem path given by
`log.path`.  See also `log.if_exists`, which controls the behavior if the
destination path already exists.

|`log.level`
|`"info"`
|Yes
|Specifies what severity of log messages should be included in the log.  Valid
values include `"trace"`, `"debug"`, `"info"`, `"warn"`, `"error"`, and
`"critical"`, which are increasing order of severity.  Log messages at the
specified level and more severe levels will be included in the log.

|`log.path`
|`"logs/server.log"`
|Only if `log.mode = "file"`
|If `log.mode` is `"file"`, this property determines the path to the log file.
See also `log.if_exists`.

|`log.if_exists`
|`"append"`
|Only if `log.mode = "file"`
|If `log.mode` is `"file"`, this property specifies what to do if the
destination log file already exists.  Valid values include `"append"` (which
appends to the existing file), `"truncate"` (which truncates the existing file
and then uses it as though it had just been created), and `"fail"` (which causes
the server to exit immediately with an error).

|===

== Design notes

The implementation is divided into several subsystems:

- **Dropshot**, a generic crate that provides facilities for implementing an
  HTTP API server with strong OpenAPI support.  This exists today.
- **Oxide Rack HTTP API layer**.  These are the parts of this crate that use
  Dropshot to provide an HTTP interface to the underlying Oxide Rack.
- **Oxide Rack**.  This is an HTTP-agnostic model of the resources in a rack.
- (still to be fleshed out) **Data storage**.  The parts of the Oxide Rack that
  persist information about resources in the rack will wind up behind a data
  storage interface.

== TODO

* Working on instances
** Update?
** Build infrastructure for supporting async operations (boot, halt, reboot),
    checking on status, etc.
** Other thoughts:
* Repo cleanup
* CI/CD?
** incorporate openapi directly into this subcrate
** rename "lib" to something else (e.g., "local_deps")
** Dropshot itself should be documented
** separate out api_model_data.rs?
* Flesh out more endpoints and simulator
* Write out road map
* General work:
** OpenAPI support: Rust macros, tooling to generate spec, client librar(ies),
   CLI
** Debugging / monitoring
*** Prometheus?
*** OpenTracing?  OpenTelemetry?
*** Dynamic tracing?
*** Core files?
*** Internal APIs for:
**** showing connected clients, recent requests, ...?
** Rack-Internal API?
*** Alerts?
*** Faults?  Support bundles?
** Audit logging
** Authentication
** Authorization
** Data storage
** Other API changes
*** regions, AZs, etc. need to be added per RFD 24
*** /racks, /servers
*** are servers going to have uuids?  Will we need a bunch of operations like
    Triton never really had around chassis swaps?
*** What's the scope of these servers?
*** CAP choices
*** Active/Active, Active/Passive, Consensus?
** TLS
** Versioning (header? path? translators for older versions?)
** Pagination? (Opaque token?  What does Stripe do?)
** Hardening (see RFD 10)
*** throttling / load shedding
** Automated testing
*** General API testing: there's a lot of boilerplate in hand-generated tests
    for each kind of resource.  Would it be reasonable / possible to have a sort
    of omnibus test that's given the OpenAPI spec (or something like it),
    creates a hierarchy with at least one of every possible resource, and does
    things like: For each possible resource
**** attempt to (create, get, put, delete) one with an invalid name
**** attempt to (GET, DELETE, PUT) one that does not exist
**** attempt to create one with invalid JSON
**** attempt to create one with a duplicate name of the one we know about
**** exercise list operation with marker and limit (may need to create many of them)
**** for each required input property:
***** attempt to create a resource without that property
**** for each input property: attempt to create a resource with invalid values
     for that property
**** list instances of that resource and expect to find the one we know about
**** GET the one instance we know about
**** DELETE the one instance we know about
**** GET the one instance we know about again and expect it to fail
**** list instances again and expect to find nothing
*** Basic functionality
*** Performance testing
*** Stress testing
*** Fault testing / under load
*** Fuzz testing
** Security review
